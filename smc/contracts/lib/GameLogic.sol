// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "./HeadsUpStorage.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

contract GameLogic is HeadsUpStorage, ReentrancyGuardUpgradeable {
    function initialize() external initializer {
        __HeadsUpStorage_init();   // initialize storage contract
        __GameLogic_init();        // initialize reentrancy + extra logic
    }

    function __GameLogic_init() internal onlyInitializing {
        __ReentrancyGuard_init();
    }


    /**
     * @dev Main function for players to flip coin with frontend-generated random number
     * @param choice Player's choice: 0 for tails, 1 for heads
     * @param randomNumber Random number generated by frontend (should be a large number)
     */
    function flipCoin(uint8 choice, uint256 randomNumber) external payable nonReentrant {
    require(choice == 0 || choice == 1, "Invalid choice: must be 0 (tails) or 1 (heads)");
    require(msg.value >= minBetAmount, "Bet amount too low");
    require(msg.value <= maxBetAmount, "Bet amount too high");
    require(
        address(this).balance >= (msg.value * PAYOUT_PERCENTAGE) / BASIS_POINTS,
        "Insufficient contract balance for potential payout"
    );
    require(randomNumber > 0, "Random number must be greater than 0");

    // Generate unique request ID
    uint256 requestId = gameCounter;
    gameCounter++;

    // Coin flip result: 0 (tails) or 1 (heads)
    uint8 coinResult = uint8(randomNumber % 2);

    // Store game request
    gameRequests[requestId] = GameRequest({
        player: msg.sender,
        amount: msg.value,
        playerChoice: choice,
        fulfilled: true,
        won: coinResult == choice,
        timestamp: block.timestamp,
        randomNumber: randomNumber,
        coinResult: coinResult
    });

    playerGames[msg.sender].push(requestId);
    totalGamesPlayed++;
    totalVolume += msg.value;

    // Event: game started
    emit GameRequested(requestId, msg.sender, msg.value, choice, block.timestamp);

    // Track payout
    uint256 payout = 0;

    if (coinResult == choice) {
        // ✅ Player wins
        payout = (msg.value * PAYOUT_PERCENTAGE) / BASIS_POINTS;

        (bool success, ) = payable(msg.sender).call{value: payout}("");
        require(success, "Payout transfer failed");
    } else {
        // ❌ Player loses → house keeps bet
        uint256 platformFee = (msg.value * HOUSE_EDGE) / BASIS_POINTS;
        platformFees += platformFee;
    }

    // Update balance tracker
    contractBalance = address(this).balance;

    // Emit final result
    emit GameResult(
        requestId,
        msg.sender,
        msg.value,
        choice,
        coinResult,
        coinResult == choice,
        payout,
        randomNumber,
        block.timestamp
    );

    emit GameCompleted(requestId, msg.sender, coinResult == choice, payout);
}

    /**
     * @dev Get the random number used for a specific game
     * @param requestId The game request ID
     * @return randomNumber The random number from frontend
     * @return coinResult The final coin flip result (0 or 1)
     */
    function getGameRandomness(uint256 requestId) 
        external 
        view 
        returns (uint256 randomNumber, uint8 coinResult) 
    {
        GameRequest memory game = gameRequests[requestId];
        require(game.fulfilled, "Game not found or not fulfilled");
        return (game.randomNumber, game.coinResult);
    }

    /**
     * @dev Get player's game history
     */
    function getPlayerGames(
        address player
    ) external view returns (uint256[] memory) {
        return playerGames[player];
    }

    /**
     * @dev Get game details by request ID
     */
    function getGameDetails(
        uint256 requestId
    ) external view returns (GameRequest memory) {
        return gameRequests[requestId];
    }

    /**
     * @dev Get contract statistics
     */
    function getContractStats()
        external
        view
        returns (
            uint256 totalGames,
            uint256 volume,
            uint256 balance,
            uint256 fees
        )
    {
        return (
            totalGamesPlayed,
            totalVolume,
            address(this).balance,
            platformFees
        );
    }

    /**
     * @dev Get current game counter
     */
    function getCurrentGameCounter() external view returns (uint256) {
        return gameCounter;
    }
}
