// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "./HeadsUpStorage.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

abstract contract GameLogic is
    HeadsUpStorage,
    ReentrancyGuardUpgradeable
{
    function __GameLogic_init() internal onlyInitializing {
        __ReentrancyGuard_init();
    }

    /**
     * @dev Main function for players to flip coin with frontend-generated random number
     * @param choice Player's choice: 0 for tails, 1 for heads
     * @param randomNumber Random number generated by frontend (should be a large number)
     */
    function flipCoin(uint8 choice, uint256 randomNumber) external payable nonReentrant {
        require(
            choice == 0 || choice == 1,
            "Invalid choice: must be 0 (tails) or 1 (heads)"
        );
        require(msg.value >= minBetAmount, "Bet amount too low");
        require(msg.value <= maxBetAmount, "Bet amount too high");
        require(
            address(this).balance >= (msg.value * PAYOUT_PERCENTAGE) / BASIS_POINTS,
            "Insufficient contract balance for potential payout"
        );
        require(randomNumber > 0, "Random number must be greater than 0");

        // Generate unique request ID
        uint256 requestId = gameCounter;
        gameCounter++;

        // Generate coin flip result (0 or 1) using modulo
        uint8 coinResult = uint8(randomNumber % 2);

        // Store game request
        gameRequests[requestId] = GameRequest({
            player: msg.sender,
            amount: msg.value,
            playerChoice: choice,
            fulfilled: true, // Immediately fulfilled since we have the random number
            won: coinResult == choice,
            timestamp: block.timestamp,
            randomNumber: randomNumber,
            coinResult: coinResult
        });

        playerGames[msg.sender].push(requestId);
        totalGamesPlayed++;
        totalVolume += msg.value;

        // Deduct platform fee immediately
        uint256 platformFee = (msg.value * HOUSE_EDGE) / BASIS_POINTS;
        platformFees += platformFee;

        // Emit game requested event
        emit GameRequested(requestId, msg.sender, msg.value, choice, block.timestamp);

        // Process game result immediately
        uint256 payout = 0;
        if (coinResult == choice) {
            // Player won
            payout = (msg.value * PAYOUT_PERCENTAGE) / BASIS_POINTS;

            // Transfer winnings to player
            (bool success, ) = payable(msg.sender).call{value: payout}("");
            require(success, "Payout transfer failed");
        }
        // If player lost, their bet stays in the contract

        // Emit comprehensive game result event
        emit GameResult(
            requestId,
            msg.sender,
            msg.value,
            choice,
            coinResult,
            coinResult == choice,
            payout,
            randomNumber,
            block.timestamp
        );
        
        emit GameCompleted(requestId, msg.sender, coinResult == choice, payout);
    }

    /**
     * @dev Get the random number used for a specific game
     * @param requestId The game request ID
     * @return randomNumber The random number from frontend
     * @return coinResult The final coin flip result (0 or 1)
     */
    function getGameRandomness(uint256 requestId) 
        external 
        view 
        returns (uint256 randomNumber, uint8 coinResult) 
    {
        GameRequest memory game = gameRequests[requestId];
        require(game.fulfilled, "Game not found or not fulfilled");
        return (game.randomNumber, game.coinResult);
    }

    /**
     * @dev Get player's game history
     */
    function getPlayerGames(
        address player
    ) external view returns (uint256[] memory) {
        return playerGames[player];
    }

    /**
     * @dev Get game details by request ID
     */
    function getGameDetails(
        uint256 requestId
    ) external view returns (GameRequest memory) {
        return gameRequests[requestId];
    }

    /**
     * @dev Get contract statistics
     */
    function getContractStats()
        external
        view
        returns (
            uint256 totalGames,
            uint256 volume,
            uint256 balance,
            uint256 fees
        )
    {
        return (
            totalGamesPlayed,
            totalVolume,
            address(this).balance,
            platformFees
        );
    }

    /**
     * @dev Get current game counter
     */
    function getCurrentGameCounter() external view returns (uint256) {
        return gameCounter;
    }
}
